<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Text Extractor</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #1f2933;
        }

        .container {
            width: min(1140px, 100%);
            background: rgba(255, 255, 255, 0.96);
            backdrop-filter: blur(14px);
            border-radius: 24px;
            box-shadow: 0 30px 70px rgba(15, 23, 42, 0.18);
            overflow: hidden;
        }

        header {
            padding: 32px 40px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        header h1 {
            margin: 0 0 8px;
            font-weight: 300;
            font-size: clamp(2rem, 4vw, 2.6rem);
        }

        header p {
            margin: 0;
            opacity: 0.88;
            max-width: 680px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 18px;
            color: white;
            text-decoration: none;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.18);
            padding: 8px 16px;
            border-radius: 999px;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        main {
            padding: 34px 40px 42px;
            display: grid;
            gap: 30px;
        }

        .upload-card,
        .results-card {
            border: 1px solid rgba(102, 126, 234, 0.18);
            border-radius: 20px;
            padding: 28px 30px;
            background: white;
        }

        .upload-card h2 {
            margin-top: 0;
            font-weight: 600;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .upload-area {
            margin-top: 18px;
            padding: 28px;
            border: 2px dashed #cbd5e0;
            border-radius: 18px;
            text-align: center;
            background: #f5f6ff;
            cursor: pointer;
            transition: border-color 0.3s ease, background 0.3s ease;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .upload-area input {
            display: none;
        }

        .upload-area strong {
            display: block;
            font-size: 1.05rem;
            margin-bottom: 6px;
        }

        .preview-grid {
            margin-top: 24px;
            display: grid;
            gap: 24px;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        }

        .preview-pane {
            background: #f8f9ff;
            border-radius: 16px;
            padding: 16px;
            box-shadow: inset 0 0 0 1px rgba(102, 126, 234, 0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .preview-pane h3 {
            margin: 0;
            font-size: 1.05rem;
            color: #39456c;
            font-weight: 600;
        }

        .preview-pane img,
        .preview-pane canvas {
            width: 100%;
            border-radius: 12px;
            background: white;
            box-shadow: 0 16px 36px rgba(148, 163, 184, 0.25);
        }

        .control-panel {
            margin-top: 20px;
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.95rem;
            color: #475569;
        }

        .control span {
            font-weight: 600;
            color: #39456c;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control input[type="range"] {
            accent-color: #667eea;
        }

        .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 28px;
            align-items: center;
        }

        button {
            appearance: none;
            border: none;
            border-radius: 999px;
            padding: 12px 28px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.45);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        button:disabled {
            background: linear-gradient(135deg, #a0aec0 0%, #cbd5e0 100%);
            cursor: not-allowed;
            box-shadow: none;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 16px 35px rgba(102, 126, 234, 0.55);
        }

        .status {
            flex: 1;
            min-width: 200px;
            color: #475569;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-bar span {
            display: block;
            height: 100%;
            width: 0;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            transition: width 0.2s ease;
        }

        .results-card h3 {
            margin: 0 0 18px;
            font-size: 1.2rem;
            font-weight: 600;
            color: #39456c;
        }

        .result-grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }

        textarea {
            width: 100%;
            min-height: 160px;
            border-radius: 16px;
            border: 1px solid #d2d6dc;
            padding: 16px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.93rem;
            background: #f9fafb;
            resize: vertical;
        }

        .fields-summary {
            display: grid;
            gap: 12px;
            margin-top: 20px;
        }

        .field-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            background: #f8f9ff;
            border-radius: 12px;
            padding: 12px 16px;
            font-size: 0.95rem;
            color: #1f2937;
        }

        .field-row span {
            font-weight: 600;
            color: #39456c;
        }

        details {
            margin-top: 18px;
            background: #f8f9ff;
            border-radius: 12px;
            padding: 12px 16px;
            color: #475569;
        }

        details summary {
            cursor: pointer;
            font-weight: 600;
            color: #39456c;
        }

        .retry-log {
            list-style: none;
            padding: 0;
            margin: 12px 0 0;
            display: grid;
            gap: 10px;
        }

        .retry-log li {
            background: white;
            border-radius: 10px;
            padding: 10px 12px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            font-size: 0.9rem;
        }

        .retry-log strong {
            color: #39456c;
        }

        @media (max-width: 720px) {
            body {
                padding: 12px;
            }

            header, main {
                padding: 24px;
            }

            .upload-card,
            .results-card {
                padding: 22px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>OCR Text Extractor</h1>
            <p>Upload a business card, crop to the card, adjust rotation, and extract structured contact data using an optimized Tesseract.js pipeline.</p>
            <a class="back-link" href="index.html">‚Üê Back to CRM dashboard</a>
        </header>
        <main>
            <section class="upload-card">
                <h2>üì§ Upload &amp; prepare</h2>
                <label class="upload-area" for="imageInput">
                    <input type="file" id="imageInput" accept="image/*">
                    <strong>Click to browse your image</strong>
                    <span>High-resolution PNG/JPG recommended. Adjust the crop and rotation below.</span>
                </label>
                <div class="preview-grid">
                    <div class="preview-pane">
                        <h3>Original</h3>
                        <img id="originalPreview" alt="Original preview" />
                    </div>
                    <div class="preview-pane">
                        <h3>Preprocessed</h3>
                        <canvas id="processedPreview" aria-label="Preprocessed output"></canvas>
                    </div>
                </div>
                <div class="control-panel">
                    <label class="control" for="cropTop">
                        <span>Crop top <output id="cropTopValue">5%</output></span>
                        <input type="range" id="cropTop" min="0" max="40" step="1" value="5">
                    </label>
                    <label class="control" for="cropBottom">
                        <span>Crop bottom <output id="cropBottomValue">5%</output></span>
                        <input type="range" id="cropBottom" min="0" max="40" step="1" value="5">
                    </label>
                    <label class="control" for="cropLeft">
                        <span>Crop left <output id="cropLeftValue">5%</output></span>
                        <input type="range" id="cropLeft" min="0" max="40" step="1" value="5">
                    </label>
                    <label class="control" for="cropRight">
                        <span>Crop right <output id="cropRightValue">5%</output></span>
                        <input type="range" id="cropRight" min="0" max="40" step="1" value="5">
                    </label>
                    <label class="control" for="rotation">
                        <span>Deskew rotation <output id="rotationValue">0¬∞</output></span>
                        <input type="range" id="rotation" min="-15" max="15" step="0.2" value="0">
                    </label>
                </div>
                <div class="actions">
                    <button id="processBtn" disabled>Run OCR pipeline</button>
                    <div class="status">
                        <div id="statusText">Select an image to begin.</div>
                        <div class="progress-bar" aria-hidden="true">
                            <span id="progress"></span>
                        </div>
                    </div>
                </div>
            </section>
            <section class="results-card">
                <h3>üìÑ OCR results &amp; debug output</h3>
                <div class="result-grid">
                    <div>
                        <h4>Raw text</h4>
                        <textarea id="rawOutput" placeholder="The detected text will appear here..." readonly></textarea>
                    </div>
                    <div>
                        <h4>Structured JSON</h4>
                        <textarea id="jsonOutput" placeholder="Normalized JSON output" readonly></textarea>
                    </div>
                </div>
                <div class="fields-summary" id="fieldSummary"></div>
                <details>
                    <summary>Retry path, warnings &amp; preprocessing</summary>
                    <ul class="retry-log" id="retryLog"></ul>
                </details>
            </section>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <script>
        const DEFAULT_TARGET_WIDTH = 2000;
        const REQUIRED_WARNINGS = [/Image too small to scale!!/i, /Line cannot be recognized!!/i];
        const EMAIL_REGEX = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i;
        const PHONE_REGEX = /(\+\d{1,3}\s*)?[\d() -]{7,}/;
        const EXTRA_LANGUAGE_MAP = [
            { lang: 'pol', pattern: /[ƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]/ },
            { lang: 'deu', pattern: /[√§√∂√º√ü√Ñ√ñ√ú·∫û]/ },
            { lang: 'fra', pattern: /[√†√¢√¶√ß√©√®√™√´√Æ√Ø√¥≈ì√π√ª√º√ø√Ä√Ç√Ü√á√â√à√ä√ã√é√è√î≈í√ô√õ√ú≈∏]/ },
            { lang: 'spa', pattern: /[√°√©√≠√≥√∫√±√º√Å√â√ç√ì√ö√ë√ú]/ }
        ];

        const state = {
            image: null,
            objectUrl: null,
            adjustments: {
                cropTop: 5,
                cropBottom: 5,
                cropLeft: 5,
                cropRight: 5,
                rotation: 0
            },
            previewCanvas: null,
            workerPromise: null,
            worker: null,
            loadedLanguages: ['eng']
        };

        const imageInput = document.getElementById('imageInput');
        const originalPreview = document.getElementById('originalPreview');
        const processedPreview = document.getElementById('processedPreview');
        const processBtn = document.getElementById('processBtn');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progress');
        const rawOutput = document.getElementById('rawOutput');
        const jsonOutput = document.getElementById('jsonOutput');
        const fieldSummary = document.getElementById('fieldSummary');
        const retryLog = document.getElementById('retryLog');

        const controls = [
            { id: 'cropTop', key: 'cropTop', output: 'cropTopValue', suffix: '%' },
            { id: 'cropBottom', key: 'cropBottom', output: 'cropBottomValue', suffix: '%' },
            { id: 'cropLeft', key: 'cropLeft', output: 'cropLeftValue', suffix: '%' },
            { id: 'cropRight', key: 'cropRight', output: 'cropRightValue', suffix: '%' },
            { id: 'rotation', key: 'rotation', output: 'rotationValue', suffix: '¬∞' }
        ];

        controls.forEach(({ id, key, output, suffix }) => {
            const input = document.getElementById(id);
            const out = document.getElementById(output);
            input.addEventListener('input', () => {
                let value = parseFloat(input.value);
                if (key !== 'rotation') {
                    value = Math.min(40, Math.max(0, value));
                    out.textContent = value.toFixed(0) + suffix;
                } else {
                    value = Math.max(-15, Math.min(15, value));
                    out.textContent = value.toFixed(1) + suffix;
                }
                state.adjustments[key] = value;
                schedulePreviewUpdate();
            });
        });

        let previewRaf = null;
        function schedulePreviewUpdate() {
            if (!state.image) return;
            if (previewRaf) cancelAnimationFrame(previewRaf);
            previewRaf = requestAnimationFrame(async () => {
                previewRaf = null;
                await updatePreview();
            });
        }

        imageInput.addEventListener('change', () => {
            const [file] = imageInput.files || [];
            rawOutput.value = '';
            jsonOutput.value = '';
            fieldSummary.innerHTML = '';
            retryLog.innerHTML = '';
            progressBar.style.width = '0%';
            statusText.textContent = file ? 'Preparing preview‚Ä¶' : 'Select an image to begin.';
            processBtn.disabled = !file;

            if (state.objectUrl) {
                URL.revokeObjectURL(state.objectUrl);
                state.objectUrl = null;
            }

            if (!file) {
                originalPreview.removeAttribute('src');
                processedPreview.width = 0;
                processedPreview.height = 0;
                state.image = null;
                return;
            }

            const url = URL.createObjectURL(file);
            state.objectUrl = url;
            const img = new Image();
            img.onload = () => {
                state.image = img;
                originalPreview.src = url;
                schedulePreviewUpdate();
            };
            img.onerror = () => {
                statusText.textContent = 'Unable to load that image. Try another file.';
                processBtn.disabled = true;
            };
            img.src = url;
        });

        async function ensureWorker() {
            if (state.worker) return state.worker;
            if (!state.workerPromise) {
                const { createWorker } = Tesseract;
                state.workerPromise = (async () => {
                    const worker = await createWorker({
                        logger: (message) => handleWorkerLog(message)
                    });
                    await worker.load();
                    await worker.loadLanguage('eng');
                    await worker.initialize('eng');
                    state.loadedLanguages = ['eng'];
                    state.worker = worker;
                    return worker;
                })();
            }
            return state.workerPromise;
        }

        let recognitionContext = null;
        function handleWorkerLog(message) {
            if (!recognitionContext) return;
            const summary = formatLog(message);
            recognitionContext.logs.push(summary);
            if (message.status === 'recognizing text' && typeof message.progress === 'number') {
                const start = recognitionContext.progressRange[0];
                const end = recognitionContext.progressRange[1];
                const pct = Math.round(start + (end - start) * message.progress);
                updateProgress(pct, `${recognitionContext.label}: ${Math.round(message.progress * 100)}%`);
            } else if (message.status) {
                updateStatus(`${recognitionContext.label}: ${message.status.replace(/_/g, ' ')}`);
            }
        }

        function updateStatus(text) {
            statusText.textContent = text;
        }

        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            if (text) {
                statusText.textContent = text;
            }
        }

        async function updatePreview() {
            if (!state.image) return;
            const { canvas } = preprocessImage(state.image, state.adjustments, { targetWidth: DEFAULT_TARGET_WIDTH });
            drawToPreview(canvas);
        }

        function drawToPreview(canvas) {
            processedPreview.width = canvas.width;
            processedPreview.height = canvas.height;
            const ctx = processedPreview.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(canvas, 0, 0);
        }

        function preprocessImage(image, adjustments, options = {}) {
            const steps = [];
            const targetWidth = Math.max(1800, options.targetWidth || DEFAULT_TARGET_WIDTH);
            const naturalWidth = image.naturalWidth || image.width;
            const naturalHeight = image.naturalHeight || image.height;

            const baseCanvas = document.createElement('canvas');
            baseCanvas.width = naturalWidth;
            baseCanvas.height = naturalHeight;
            baseCanvas.getContext('2d').drawImage(image, 0, 0);

            const crop = {
                top: Math.min(Math.max(adjustments.cropTop || 0, 0), 40) / 100,
                bottom: Math.min(Math.max(adjustments.cropBottom || 0, 0), 40) / 100,
                left: Math.min(Math.max(adjustments.cropLeft || 0, 0), 40) / 100,
                right: Math.min(Math.max(adjustments.cropRight || 0, 0), 40) / 100
            };

            const cropRect = {
                x: Math.round(naturalWidth * crop.left),
                y: Math.round(naturalHeight * crop.top),
                width: Math.round(naturalWidth * (1 - crop.left - crop.right)),
                height: Math.round(naturalHeight * (1 - crop.top - crop.bottom))
            };

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropRect.width;
            cropCanvas.height = cropRect.height;
            cropCanvas.getContext('2d').drawImage(
                baseCanvas,
                cropRect.x,
                cropRect.y,
                cropRect.width,
                cropRect.height,
                0,
                0,
                cropRect.width,
                cropRect.height
            );
            steps.push('crop');

            const rotation = (adjustments.rotation || 0) * Math.PI / 180;
            const absRotation = Math.abs(rotation);
            const rotatedWidth = Math.round(cropCanvas.width * Math.cos(absRotation) + cropCanvas.height * Math.sin(absRotation));
            const rotatedHeight = Math.round(cropCanvas.width * Math.sin(absRotation) + cropCanvas.height * Math.cos(absRotation));
            const rotatedCanvas = document.createElement('canvas');
            rotatedCanvas.width = rotatedWidth;
            rotatedCanvas.height = rotatedHeight;
            const rotatedCtx = rotatedCanvas.getContext('2d');
            rotatedCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
            rotatedCtx.rotate(rotation);
            rotatedCtx.drawImage(cropCanvas, -cropCanvas.width / 2, -cropCanvas.height / 2);
            steps.push(`deskew-${(adjustments.rotation || 0).toFixed(1)}deg`);

            const scale = targetWidth / rotatedCanvas.width;
            const scaledWidth = Math.round(targetWidth);
            const scaledHeight = Math.round(rotatedCanvas.height * scale);
            const scaledCanvas = document.createElement('canvas');
            scaledCanvas.width = scaledWidth;
            scaledCanvas.height = scaledHeight;
            const scaledCtx = scaledCanvas.getContext('2d');
            scaledCtx.imageSmoothingQuality = 'high';
            scaledCtx.drawImage(rotatedCanvas, 0, 0, scaledWidth, scaledHeight);
            steps.push(`scale-${scaledWidth}`);

            const ctx = scaledCanvas.getContext('2d');
            const { width, height } = scaledCanvas;
            const imageData = ctx.getImageData(0, 0, width, height);
            const gray = new Uint8ClampedArray(width * height);

            for (let i = 0, j = 0; i < imageData.data.length; i += 4, j += 1) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1];
                const b = imageData.data[i + 2];
                gray[j] = Math.round(0.2126 * r + 0.7152 * g + 0.0722 * b);
            }
            steps.push('grayscale');

            const denoised = convolveGray(gray, width, height, [
                1, 2, 1,
                2, 4, 2,
                1, 2, 1
            ], 16);
            steps.push('gaussian-blur-3x3');

            const threshold = otsuThreshold(denoised);
            const binary = new Uint8ClampedArray(width * height);
            for (let i = 0; i < denoised.length; i++) {
                binary[i] = denoised[i] > threshold ? 255 : 0;
            }
            steps.push('otsu');

            const opened = morphologyOpen(binary, width, height);
            steps.push('morph-open');

            const sharpened = applyUnsharpBinary(opened, width, height, 0.4);
            steps.push('sharpen');

            const finalData = ctx.createImageData(width, height);
            for (let i = 0, j = 0; i < finalData.data.length; i += 4, j += 1) {
                const value = sharpened[j];
                finalData.data[i] = value;
                finalData.data[i + 1] = value;
                finalData.data[i + 2] = value;
                finalData.data[i + 3] = 255;
            }
            ctx.putImageData(finalData, 0, 0);

            return { canvas: scaledCanvas, steps, threshold };
        }

        function convolveGray(input, width, height, kernel, divisor) {
            const output = new Uint8ClampedArray(input.length);
            const kSize = Math.sqrt(kernel.length);
            const kOffset = Math.floor(kSize / 2);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let acc = 0;
                    for (let ky = -kOffset; ky <= kOffset; ky++) {
                        for (let kx = -kOffset; kx <= kOffset; kx++) {
                            const px = Math.min(width - 1, Math.max(0, x + kx));
                            const py = Math.min(height - 1, Math.max(0, y + ky));
                            const weight = kernel[(ky + kOffset) * kSize + (kx + kOffset)];
                            acc += input[py * width + px] * weight;
                        }
                    }
                    output[y * width + x] = Math.min(255, Math.max(0, Math.round(acc / divisor)));
                }
            }
            return output;
        }

        function applyUnsharpBinary(input, width, height, amount = 0.4) {
            const blurred = convolveGray(input, width, height, [
                1, 2, 1,
                2, 4, 2,
                1, 2, 1
            ], 16);
            const output = new Uint8ClampedArray(input.length);
            for (let i = 0; i < input.length; i++) {
                const sharpened = input[i] + amount * (input[i] - blurred[i]);
                output[i] = sharpened > 128 ? 255 : 0;
            }
            return output;
        }

        function otsuThreshold(values) {
            const histogram = new Array(256).fill(0);
            values.forEach((v) => histogram[v]++);
            const total = values.length;
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }
            let sumB = 0;
            let wB = 0;
            let maximum = 0;
            let threshold = 0;

            for (let i = 0; i < 256; i++) {
                wB += histogram[i];
                if (wB === 0) continue;
                const wF = total - wB;
                if (wF === 0) break;
                sumB += i * histogram[i];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const between = wB * wF * (mB - mF) * (mB - mF);
                if (between > maximum) {
                    maximum = between;
                    threshold = i;
                }
            }
            return threshold;
        }

        function morphologyOpen(binary, width, height) {
            const eroded = new Uint8ClampedArray(binary.length);
            const dilated = new Uint8ClampedArray(binary.length);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let min = 255;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const px = Math.min(width - 1, Math.max(0, x + kx));
                            const py = Math.min(height - 1, Math.max(0, y + ky));
                            min = Math.min(min, binary[py * width + px]);
                        }
                    }
                    eroded[y * width + x] = min;
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let max = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const px = Math.min(width - 1, Math.max(0, x + kx));
                            const py = Math.min(height - 1, Math.max(0, y + ky));
                            max = Math.max(max, eroded[py * width + px]);
                        }
                    }
                    dilated[y * width + x] = max;
                }
            }

            return dilated;
        }

        function formatLog(message) {
            if (!message) return '';
            if (typeof message === 'string') return message;
            if (message.text) return message.text;
            if (message.status) {
                const progress = typeof message.progress === 'number' ? ` ${(message.progress * 100).toFixed(1)}%` : '';
                return `${message.status.replace(/_/g, ' ')}${progress}`;
            }
            if (message.message) return message.message;
            return JSON.stringify(message);
        }

        function detectExtraLanguage(text) {
            if (!text) return null;
            for (const entry of EXTRA_LANGUAGE_MAP) {
                if (!state.loadedLanguages.includes(entry.lang) && entry.pattern.test(text)) {
                    return entry.lang;
                }
            }
            return null;
        }

        function meanConfidence(words) {
            if (!words || words.length === 0) return 0;
            const total = words.reduce((acc, word) => acc + (word.confidence || 0), 0);
            return total / words.length;
        }

        function summarizeWords(words) {
            if (!words || words.length === 0) return null;
            let x0 = Infinity;
            let y0 = Infinity;
            let x1 = -Infinity;
            let y1 = -Infinity;
            words.forEach((word) => {
                if (word.bbox) {
                    x0 = Math.min(x0, word.bbox.x0);
                    y0 = Math.min(y0, word.bbox.y0);
                    x1 = Math.max(x1, word.bbox.x1);
                    y1 = Math.max(y1, word.bbox.y1);
                }
            });
            if (!Number.isFinite(x0) || !Number.isFinite(x1)) {
                return null;
            }
            return { x0, y0, x1, y1 };
        }

        async function extractCardData(image, adjustments, { onAttempt, onProgress, onStatus } = {}) {
            await ensureWorker();
            const worker = state.worker;
            const attemptHistory = [];
            const warningsSet = new Set();
            const baseTargetWidth = DEFAULT_TARGET_WIDTH;
            const attemptSettings = [
                { targetWidth: baseTargetWidth, psm: 6 },
                { targetWidth: Math.max(2200, baseTargetWidth + 200), psm: 6 },
                { targetWidth: Math.max(2600, baseTargetWidth + 400), psm: 4 }
            ];

            let finalGeneral = null;
            let finalPreprocess = null;
            let generalPSMUsed = 6;
            let extraLanguageApplied = false;

            for (let attemptIndex = 0; attemptIndex < attemptSettings.length; attemptIndex++) {
                const attempt = attemptSettings[attemptIndex];
                if (onStatus) onStatus(`Preprocessing (target width ${attempt.targetWidth}px)‚Ä¶`);
                const preprocessResult = preprocessImage(image, adjustments, { targetWidth: attempt.targetWidth });
                const historyEntry = {
                    attempt: attemptIndex + 1,
                    targetWidth: preprocessResult.canvas.width,
                    psm: attempt.psm,
                    steps: preprocessResult.steps,
                    warnings: []
                };

                let rerun = false;
                do {
                    rerun = false;
                    const logs = [];
                    recognitionContext = {
                        label: 'General pass',
                        logs,
                        progressRange: [attemptIndex === 0 ? 0 : 20, 70]
                    };
                    await worker.setParameters({
                        user_defined_dpi: '300',
                        tessedit_pageseg_mode: String(attempt.psm),
                        preserve_interword_spaces: '1',
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+@._-()/&,: '
                    });
                    const generalResult = await worker.recognize(preprocessResult.canvas);
                    recognitionContext = null;

                    const detectedLanguage = detectExtraLanguage(generalResult.data.text);
                    if (detectedLanguage && !state.loadedLanguages.includes(detectedLanguage)) {
                        await worker.loadLanguage(detectedLanguage);
                        await worker.initialize(`eng+${detectedLanguage}`);
                        state.loadedLanguages.push(detectedLanguage);
                        extraLanguageApplied = true;
                        rerun = true;
                        continue;
                    }

                    const warningMessages = logs.filter((log) => REQUIRED_WARNINGS.some((regex) => regex.test(log)));
                    warningMessages.forEach((warning) => warningsSet.add(warning));
                    historyEntry.warnings.push(...warningMessages);

                    const shouldRetry = warningMessages.length > 0 && attemptIndex < attemptSettings.length - 1;
                    if (shouldRetry) {
                        recognitionContext = null;
                        break;
                    }

                    finalGeneral = generalResult;
                    finalPreprocess = preprocessResult;
                    generalPSMUsed = attempt.psm;
                    historyEntry.success = true;
                    const extraLangs = state.loadedLanguages.slice(1);
                    if (extraLangs.length) {
                        historyEntry.extraLanguage = extraLangs.join(', ');
                    }
                    attemptHistory.push({ ...historyEntry });
                    extraLanguageApplied = false;
                    break;
                } while (rerun);

                if (finalGeneral) {
                    break;
                }

                const extraLangs = state.loadedLanguages.slice(1);
                if (extraLangs.length) {
                    historyEntry.extraLanguage = extraLangs.join(', ');
                }
                historyEntry.success = false;
                attemptHistory.push({ ...historyEntry });
            }

            if (!finalGeneral) {
                const lastAttempt = attemptSettings[attemptSettings.length - 1];
                finalPreprocess = preprocessImage(image, adjustments, { targetWidth: lastAttempt.targetWidth });
                recognitionContext = {
                    label: 'General pass',
                    logs: [],
                    progressRange: [20, 70]
                };
                await state.worker.setParameters({
                    user_defined_dpi: '300',
                    tessedit_pageseg_mode: String(lastAttempt.psm),
                    preserve_interword_spaces: '1',
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+@._-()/&,: '
                });
                finalGeneral = await state.worker.recognize(finalPreprocess.canvas);
                recognitionContext = null;
                generalPSMUsed = lastAttempt.psm;
            }

            updateProgress(75, 'Running targeted passes‚Ä¶');

            recognitionContext = {
                label: 'Email pass',
                logs: [],
                progressRange: [75, 88]
            };
            await state.worker.setParameters({
                user_defined_dpi: '300',
                tessedit_pageseg_mode: '11',
                preserve_interword_spaces: '1',
                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+@._-'
            });
            const emailResult = await state.worker.recognize(finalPreprocess.canvas);
            recognitionContext = null;

            recognitionContext = {
                label: 'Phone pass',
                logs: [],
                progressRange: [88, 100]
            };
            await state.worker.setParameters({
                user_defined_dpi: '300',
                tessedit_pageseg_mode: '11',
                preserve_interword_spaces: '1',
                tessedit_char_whitelist: '+0123456789()- '
            });
            const phoneResult = await state.worker.recognize(finalPreprocess.canvas);
            recognitionContext = null;

            const rawText = (finalGeneral.data.text || '').trim();

            const nameField = extractName(finalGeneral.data.lines || []);

            const emailField = extractEmail(emailResult.data.words || []);
            const phoneField = extractPhone(phoneResult.data.words || []);

            await maybeRefineLowConfidence(finalPreprocess.canvas, nameField, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Å√Ä√Ç√Ñ√É√Ö√á√â√à√ä√ã√ç√å√é√è√ë√ì√í√î√ñ√ï√ò√ö√ô√õ√ú√ù≈∏ƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª ', 7);
            await maybeRefineLowConfidence(finalPreprocess.canvas, emailField, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+@._-', 7);
            await maybeRefineLowConfidence(finalPreprocess.canvas, phoneField, '+0123456789()- ', 7, normalizePhoneValue);

            const fields = {
                name: {
                    value: nameField.value,
                    confidence: roundConfidence(nameField.confidence)
                },
                phone: {
                    value: phoneField.value,
                    confidence: roundConfidence(phoneField.confidence)
                },
                email: {
                    value: emailField.value,
                    confidence: roundConfidence(emailField.confidence)
                }
            };

            const debug = {
                warnings: Array.from(warningsSet),
                dpi: 300,
                psm_general: generalPSMUsed,
                image_width_px: finalPreprocess.canvas.width,
                preprocess_steps: finalPreprocess.steps
            };

            const structured = {
                raw_text: rawText,
                fields,
                debug
            };

            if (onProgress) onProgress(100);
            if (onStatus) onStatus('Completed');

            return {
                structured,
                attemptHistory,
                canvas: finalPreprocess.canvas,
                nameField,
                phoneField,
                emailField
            };
        }

        function roundConfidence(value) {
            if (value == null) return 0;
            return Math.max(0, Math.min(100, Math.round(value * 100) / 100));
        }

        function extractName(lines) {
            let best = { value: null, confidence: 0, words: null, bbox: null };
            const uppercaseToken = /^[A-Z√Ä-√ù≈ö≈Å≈π≈ªƒÜ≈É√ì][\p{L}'‚Äô.-]*$/u;
            for (const line of lines) {
                if (!line || !line.text) continue;
                const tokens = line.text.trim().split(/\s+/).filter(Boolean);
                if (tokens.length < 2) continue;
                if (/[0-9@()+]/.test(line.text)) continue;
                const firstTwo = tokens.slice(0, 2);
                if (!firstTwo.every((token) => uppercaseToken.test(token))) continue;
                const confidence = meanConfidence(line.words || []);
                if (confidence > best.confidence) {
                    best = {
                        value: tokens.join(' ').trim(),
                        confidence,
                        words: line.words || [],
                        bbox: summarizeWords(line.words || [])
                    };
                }
            }
            return best;
        }

        function extractEmail(words) {
            let best = { value: null, confidence: 0, words: null, bbox: null };
            for (let i = 0; i < words.length; i++) {
                for (let len = 1; len <= 3 && i + len <= words.length; len++) {
                    const segment = words.slice(i, i + len);
                    const combined = segment.map((w) => w.text.trim()).join('');
                    const candidate = combined.replace(/\s+/g, '');
                    if (!candidate || !EMAIL_REGEX.test(candidate)) continue;
                    const confidence = meanConfidence(segment);
                    if (confidence > best.confidence) {
                        best = {
                            value: candidate.toLowerCase(),
                            confidence,
                            words: segment,
                            bbox: summarizeWords(segment)
                        };
                    }
                }
            }
            return best;
        }

        function extractPhone(words) {
            let best = { value: null, confidence: 0, words: null, bbox: null };
            for (let i = 0; i < words.length; i++) {
                let combined = '';
                for (let len = 1; len <= 6 && i + len <= words.length; len++) {
                    const segment = words.slice(i, i + len);
                    combined = segment.map((w) => w.text.trim()).join(' ');
                    const normalized = combined.replace(/[^0-9+]/g, '');
                    const regex = new RegExp(PHONE_REGEX.source, PHONE_REGEX.flags || 'g');
                    if (!regex.test(combined)) continue;
                    const confidence = meanConfidence(segment);
                    const formatted = normalizePhoneValue(combined.trim());
                    if (!formatted) continue;
                    if (confidence > best.confidence) {
                        best = {
                            value: formatted,
                            confidence,
                            words: segment,
                            bbox: summarizeWords(segment)
                        };
                    }
                }
            }
            return best;
        }

        function normalizePhoneValue(value) {
            if (!value) return null;
            const digits = value.replace(/[^0-9+]/g, '');
            if (!digits) return null;
            if (digits.startsWith('+')) {
                const parts = ['+'];
                for (let i = 1; i < digits.length; i++) {
                    const ch = digits[i];
                    if (/\d/.test(ch)) parts.push(ch);
                }
                return parts.join('');
            }
            return digits.replace(/\D/g, '');
        }

        async function maybeRefineLowConfidence(canvas, field, whitelist, psm, postProcess) {
            if (!field || !field.value) return;
            if (field.confidence >= 70) return;
            if (!field.bbox) return;
            const { x0, y0, x1, y1 } = field.bbox;
            if ([x0, y0, x1, y1].some((v) => typeof v !== 'number' || Number.isNaN(v))) return;
            const padding = 6;
            const sx = Math.max(0, Math.round(x0 - padding));
            const sy = Math.max(0, Math.round(y0 - padding));
            const sWidth = Math.max(1, Math.min(canvas.width - sx, Math.round(x1 - x0 + padding * 2)));
            const sHeight = Math.max(1, Math.min(canvas.height - sy, Math.round(y1 - y0 + padding * 2)));
            const region = document.createElement('canvas');
            region.width = sWidth;
            region.height = sHeight;
            const ctx = region.getContext('2d');
            ctx.drawImage(canvas, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

            recognitionContext = {
                label: 'Refine field',
                logs: [],
                progressRange: [65, 75]
            };
            await state.worker.setParameters({
                user_defined_dpi: '300',
                tessedit_pageseg_mode: String(psm),
                preserve_interword_spaces: '1',
                tessedit_char_whitelist: whitelist
            });
            const refined = await state.worker.recognize(region);
            recognitionContext = null;

            const refinedWords = refined.data.words || [];
            const refinedConfidence = meanConfidence(refinedWords);
            let refinedValue = (refined.data.text || '').trim();
            if (postProcess) {
                refinedValue = postProcess(refinedValue);
            }
            if (!refinedValue) return;
            if (refinedConfidence > field.confidence) {
                field.value = refinedValue;
                field.confidence = refinedConfidence;
            }
        }

        processBtn.addEventListener('click', async () => {
            if (!state.image) return;
            processBtn.disabled = true;
            updateStatus('Initializing worker‚Ä¶');
            updateProgress(5);
            try {
                const result = await extractCardData(state.image, state.adjustments, {
                    onProgress: (value) => updateProgress(value),
                    onStatus: (text) => updateStatus(text)
                });
                drawToPreview(result.canvas);
                rawOutput.value = result.structured.raw_text || '[No text detected]';
                jsonOutput.value = JSON.stringify(result.structured, null, 2);
                renderFieldSummary(result.structured.fields);
                renderRetryLog(result.attemptHistory, result.structured.debug);
            } catch (error) {
                console.error(error);
                updateStatus('An error occurred while processing the image.');
                rawOutput.value = error && error.message ? error.message : String(error);
            } finally {
                processBtn.disabled = false;
            }
        });

        function renderFieldSummary(fields) {
            fieldSummary.innerHTML = '';
            Object.entries(fields).forEach(([key, data]) => {
                const row = document.createElement('div');
                row.className = 'field-row';
                const label = document.createElement('span');
                label.textContent = key.toUpperCase();
                const value = document.createElement('div');
                value.textContent = `${data.value ?? '‚Äî'} (conf ${data.confidence.toFixed(2)})`;
                row.appendChild(label);
                row.appendChild(value);
                fieldSummary.appendChild(row);
            });
        }

        function renderRetryLog(history, debug) {
            retryLog.innerHTML = '';
            const combined = history.length ? history : [{ attempt: 1, targetWidth: debug.image_width_px, psm: debug.psm_general, warnings: debug.warnings || [], success: true }];
            combined.forEach((entry) => {
                const li = document.createElement('li');
                const status = entry.success ? '‚úÖ' : '‚ö†Ô∏è';
                const warningsText = entry.warnings && entry.warnings.length ? `Warnings: ${entry.warnings.join('; ')}` : 'Warnings: none';
                const extraLang = entry.extraLanguage ? ` | extra language: ${entry.extraLanguage}` : '';
                li.innerHTML = `<strong>${status} Attempt ${entry.attempt}:</strong> scale-${entry.targetWidth}, PSM ${entry.psm}${extraLang}<br>${warningsText}<br>Steps: ${entry.steps.join(', ')}`;
                retryLog.appendChild(li);
            });
            if (debug && debug.preprocess_steps) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>Final preprocess steps:</strong> ${debug.preprocess_steps.join(', ')}`;
                retryLog.appendChild(li);
            }
        }

        window.extractCardData = extractCardData;
    </script>
</body>
</html>
